// MySelector.C
// Helen Persson 

#define MySelector_cxx
// The class definition in MySelector.h has been generated automatically
// by the ROOT utility TTree::MakeSelector(). This class is derived
// from the ROOT class TSelector. For more information on the TSelector
// framework see $ROOTSYS/README/README.SELECTOR or the ROOT User Manual.


// The following methods are defined in this file:
//    Begin():        called every time a loop on the tree starts,
//                    a convenient place to create your histograms.
//    SlaveBegin():   called after Begin(), when on PROOF called only on the
//                    slave servers.
//    Process():      called for each event, in this function you decide what
//                    to read and fill your histograms.
//    SlaveTerminate: called at the end of the loop on the tree, when on PROOF
//                    called only on the slave servers.
//    Terminate():    called at the end of the loop on the tree,
//                    a convenient place to draw/fit your histograms.
//
// To use this file, try the following session on your Tree T:
//
// root> T->Process("MySelector.C")
// root> T->Process("MySelector.C","some options")
// root> T->Process("MySelector.C+")
//
// If you run gROOT.ProcessLine(..........) use T->Process("MySelector","some options") in program
//


//C++ includes
#include <iostream>
#include <vector>
#include <string>     // std::string, std::stoi
#include <fstream>
#include <typeinfo>       // operator typeid

// ROOT includes
#include <TLorentzVector.h>
#include "TString.h"

//Autogenerated
#include "MySelector.h"
#include <TStyle.h>
#include "TCanvas.h"
#include <TH1.h>
#include <TH2.h>

// Makes mT2 variable possible to calculate 
#include "./CalcGenericMT2/CalcGenericMT2/MT2_ROOT.h" 





using namespace std; 


void MySelector::Begin(TTree * /*tree*/)
{
  // The Begin() function is called at the start of the query.
  // When running with PROOF Begin() is only called on the client.
  // The tree argument is deprecated (on PROOF 0 is passed).
 
  // TESTING ---------------
  // cuts = cut1(cut_string);
  
  //--------------------------


  // The line below was automaticly generated
  TString option = GetOption();

  //==================================================
  //
  // Read in and split up incomming options from RunSelector.py
  // info elemets 0 - 3 are always in the same format, 
  // info element 4 and 5 depends on if there is background, data or signal sendt in
  //
  //==================================================
  
  string temp;
  
  TObjArray *tx = option.Tokenize(" ");

  for (Int_t i = 0; i < tx->GetEntries(); i++) 
    {
      temp=((TObjString *)(tx->At(i)))->String();
      info.push_back(temp);
    }

  info_size = info.size();  
  // ONLY FOR DEBUGGING
  // cout << "info size: " << info_size << endl;   
  
  timestamp = info[0];
  saving_path = info[1];
  inputType = info[2];
  cut_string = info[3];
  timeperiod = info[4];
  iso_point = info[5];

  /* //ONLY FOR DEBUGGING
  // Printing out what comes as info in to selector
  for (int i = 0, k =info.size(); i < k; i++){
    cout << info[i] << endl;
  }
  */

   
  if (inputType == "bkg")
    { 
      background_elm = info[6];
      //cout << "Processing in selector: " << background_elm << "for period " << timeperiod << endl;
    } 

  //else if (inputType == "data15-16" or inputType == "data17" or inputType == "data18" or inputType == "data15-17" or inputType == "data15-18")
  else if (inputType == "data")
    {
      data_name = inputType;
      //cout << "Processing in selector: " << data_name << "for period " << timeperiod << endl;
    }    
  else if (inputType == "signal")
    {
      signal_samp = info[6]; 
      //cout << "Processing in selector: " << signal_samp << "for period " << timeperiod << endl;
    } 

   else 
     {
       fake_samp = inputType;
     }

  //cout << "Im here: give out info" << endl;
  cout << inputType << iso_point << endl; 
  //==================================================
  //
  // Initialize variables used for counting and cutflow
  //
  //==================================================

  cout << "inputType is: " << inputType << endl;
 
  n_events_processed = 0; 

  cut_list = {"Preselection", "Flavor", "Sign","nJetB", "nJet", "mll", "met_Et", "met_EtSign", "mT2"};
  /*
  eventCount["preselection"] = 0;
  eventCount["flavor"] = 0;
  eventCount["sign"] = 0;
  eventCount["nJet"] = 0;
  eventCount["mll"] = 0;
  eventCount["met_Et"] = 0;
  eventCount["met_EtSign"] = 0;
  eventCount["mT2"] = 0;
  */
  //cout << "Im here: setting eventCount = 0" << endl;

  //==================================================
  //
  // Seting up variables to plot
  //
  //==================================================
  variables ={"lepPt", "mll", "met_Et", "mT2"};


  if (cut_string == "all")
    { regions = {"Preselection", "SR-SF-0J","SR-SF-1J", "SR-DF-0J", "SR-DF-1J", "SR-SF-0J-ee", "SR-SF-1J-ee", "SR-SF-0J-mumu", 
      	         "SR-SF-1J-mumu", "VR-WW-0J", "VR-WW-1J", "CR-top", "CR-WW", "CR-VZ"};
    }
  else
    {
      cout << "Regions are chosen to be: " << cut_string << endl;
      regions.push_back(cut_string);
      //cout << regions[0] << " " << regions[1] << endl;
    }

  //cout << "Im here: setting up variables" << endl;

  //==================================================
  //
  // Initialize histograms + event counting
  //
  //==================================================

  
  for( int i = 0, j = variables.size(); i < j; i++)
    {   
      for (int k = 0, l = regions.size(); k < l; k++)
      {
	my_string =  variables[i] + "_" + regions[k];
	//cout << k << l << i << j << endl;
	myString.push_back(my_string);
	histogram[my_string] = new TH1F("hist_" + my_string, "hist_" +  my_string, 1000, 0, 1000);
      }
    }

  for (int k = 0, l = regions.size(); k < l; k ++)
    {
      for (int i = 0, j = cut_list.size(); i < j; i++)
	{

	  eventCount[regions[k]][cut_list[i]] = 0; 
	}
    }



  h_extra = {"nJetB", "nJetLight", "nLepSignal", "nLepBase"};
  
  for (int k = 0, l = h_extra.size(); k < l; k++)
    {
      myString.push_back(h_extra[k]);
      histogram[h_extra[k]] = new TH1F("hist_" + h_extra[k] , "hist_" + h_extra[k], 10, 0, 10);
    }



  histogram2D["nlepbase_vs_nlepsign"] = new TH2D("hist_baseVSsignal","hist_baseVSsignal", 4, 0, 4, 4, 0 ,4);
  
  //cout << "Im here: end of Begin" << endl;


}

// Begin - end
//====================================================================================================





void MySelector::SlaveBegin(TTree * /*tree*/)
{
   // The SlaveBegin() function is called after the Begin() function.
   // When running with PROOF SlaveBegin() is called on each slave server.
   // The tree argument is deprecated (on PROOF 0 is passed).
   
   // The line below was automicly generated
   TString option = GetOption();
  

}
// SlaveBegin - end
//====================================================================================================





Bool_t MySelector::Process(Long64_t entry)
{
   // The Process() function is called for each entry in the tree (or possibly
   // keyed object in the case of PROOF) to be processed. The entry argument
   // specifies which entry in the currently loaded tree is to be processed.
   // When processing keyed objects with PROOF, the object is already loaded
   // and is available via the fObject pointer.
   //
   // This function should contain the \"body\" of the analysis. It can contain
   // simple or elaborate selection criteria, run algorithms on the data
   // of the event and typically fill histograms.
   //
   // The processing can be stopped by calling Abort().
   //
   // Use fStatus to set the return value of TTree::Process().
   //
   // The return value is currently not used.


   // Donâ€™t delete this line! Without it the program will crash - comment frome some ppt slide
   fReader.SetLocalEntry(entry);

   // Printing progression
   n_events_processed += 1;
   if (n_events_processed % 1000000 == 0) cout << "Processed " << n_events_processed << endl;

  // Variable used to do actual filling of histograms
  cuts = false;                  


  //==================================================
  //
  // Weights
  //
  //==================================================  

  if (inputType == "bkg" or inputType == "signal")
    {

      double scalelumi = (*RandomRunNumber) < 320000 ? 36207.65 :(((*RandomRunNumber) > 320000 && (*RandomRunNumber) < 348000) ? 44307.4
: 58450.1);
      weights = scalelumi*(*pileupWeight)*(*leptonWeight)*(*eventWeight)*(*genWeight)*(*bTagWeight)*(*jvtWeight);
    }  

  else if (inputType == "fakes")
    {
      // Remember to comment in/out if running or not running fakes.      

      weights = MM_weight.At(iso_point.Atoi());
      //cout << "Check to make sure correct weight for fakes" << endl;  
     }
   
  /*else if (inputType == "signal") 
    {
            double scalelumi = (*RandomRunNumber) < 320000 ? 36207.65 :(((*RandomRunNumber) > 320000 && (*RandomRunNumber) < 348000) ? 44307.4
: 58450.1);
      weights = scalelumi*(*pileupWeight)*(*leptonWeight)*(*eventWeight)*(*genWeight)*(*bTagWeight)*(*jvtWeight); 
    }*/

  else
    {weights = 1;}

  //==================================================
  //
  // Cuts - Preselection
  //
  //================================================== 

  // Cut for jets

  nJet = 0; 
  nJetLight = 0; 
  nJetB = 0;

  for (int i = 0, k = jetPt.GetSize(); i < k; i++)
    {
      // Demand jetPt > 20
      if (jetPt[i] <= 20)
	{continue;}

      if (!jetSignal->at(i) or !jetPassOR->at(i))
	{continue;}

      // Demand jetEta < 2.4
      if (fabs(jetEta[i]) > 2.4)
	{continue;}
     
      // To remove pile-up ?  
      if(jetPt[i] < 120 && fabs(jetJVT[i]) <= 0.59)
	{continue;}
      
      nJet += 1; 
      if (jetMV2c10[i]>0.11)
	{nJetB += 1;}
      else
	{nJetLight += 1;}
    }
  



  // Cuts for leptons - baseline and signal
  nLepSignal = 0;
  nLepBase = 0;
  lepIndex.clear();

  for (int i = 0, k = lepPt.GetSize(); i < k; i++)
    { 
      // Demand lepPt > 25
      if (lepPt[i] <= 25)
	{continue;}


      
      // Electron requirement
      if (lepFlavor[i] == 1 && fabs(lepEta[i]) > 2.47)
	{continue;}


      // Medium reqirement on baseline leptons
      if (iso_point == "0" or iso_point == "2")
	{ 
	  if (!lepMedium->at(i))
	    {continue;}
	}


      // If muon demand lepEta < 2.7
      if(lepFlavor[i] == 2 && fabs(lepEta[i]) > 2.7)
	{continue;}


      if((fabs(lepZ0SinTheta[i])>=0.5))
	{continue;}

      nLepBase += 1;
     
      lepIndex.push_back(i);
      // Check if it is a signal lepton with func isSignalLep
      if (!isSignalLep(i, iso_point))
	{continue;}
      
      nLepSignal += 1;

    }



  //==================================================
  //
  // Filling baseline and signal histograms
  //  
  //================================================== 
  
  histogram["nLepSignal"]->Fill(nLepSignal, weights);
  histogram["nLepBase"]->Fill(nLepBase, weights);

  histogram2D["nlepbase_vs_nlepsign"]->Fill(nLepBase, nLepSignal, weights);


  //==================================================
  //
  // Require 2 leptons 
  //  
  //================================================== 


  if ( inputType != "fakes")
    {
      if ( !(nLepBase == 2 and nLepSignal == 2))
	{return true;}
    }
  else
    {
      if ( ! (nLepBase == 2))
	{return true;}
    }


  // Find index for the actual 2 leading leptons
  Lidx1 = lepIndex.at(0);
  Lidx2 = lepIndex.at(1);

  if (inputType == "bkg" or inputType == "fakes")
    {
      if (! lepIsPR->at(Lidx1) && ! lepIsPR->at(Lidx2))
	{return true;}
    }



  //==================================================
  //
  // Filling jet histograms
  // Preselection cut on jets 
  //
  //================================================== 
  histogram["nJetB"]->Fill(nJetB, weights);
  histogram["nJetLight"]->Fill(nJetLight, weights);


  
  if (nJetB > 0)
    {return true;}

  if (nJetLight > 1)
    {return true;}

  //==================================================
  //
  // Calculation of mT2 variable
  //
  //================================================== 

  TLorentzVector lep1;
  TLorentzVector lep2;
  TLorentzVector met_tlv;

  lep1.SetPtEtaPhiM(lepPt[Lidx1], lepEta[Lidx1], lepPhi[Lidx1], lepM[Lidx1]); 
  lep2.SetPtEtaPhiM(lepPt[Lidx2], lepEta[Lidx2], lepPhi[Lidx2], lepM[Lidx2]); 
  met_tlv.SetPtEtaPhiM((*met_Et), 0.0, (*met_Phi), 0.0);

  ComputeMT2 mycalc = ComputeMT2(lep1, lep2, met_tlv, 0., 0.);
  mT2 = mycalc.Compute();


  //==================================================
  //
  // Cuts, counting and filling histograms
  // 
  // Remember preselection cuts involve:  no more than 1 light jet, exactly 2L, lepPt > 25
  //
  //==================================================

  //eventCount["preselection"] += weights;



  // Preselection
  if ( find(regions.begin(), regions.end(), "Preselection") != regions.end())
    {
      //cuts = true;
      histogram["lepPt_Preselection"]->Fill(lepPt[Lidx1], weights);
      histogram["mll_Preselection"]->Fill(*mll, weights);
      histogram["met_Et_Preselection"]->Fill(*met_Et, weights );
      histogram["mT2_Preselection"]->Fill(mT2, weights);

      eventCount["Preselection"]["Preselection"] += weights;
    }


  // Cuts e e, e mu, mu e, mu mu

  // CR-top

  if ( find(regions.begin(), regions.end(), "CR-top") != regions.end())
    {
      eventCount["CR-top"]["Preselection"] += weights;
      if (Flavor("DF", Lidx1, Lidx2)) 
	{eventCount["CR-top"]["Flavor"] += weights;
	  if (WantedBJets(1, nJetB))
	    {eventCount["CR-top"]["nBjet"] += weights;
	      if (WantedLightJets(0, nJetB))
		{eventCount["CR-top"]["nJet"] += weights;
		  if (mT2_cut("inclusive", 80, 100000000))
		    {
		      eventCount["CR-top"]["mT2"] += weights;
		      if (met_Et_cut("larger", 110, 1000000))
			{
			  eventCount["CR-top"]["met_Et"] += weights;
			  if (met_Sign_cut("larger", 10, 10000000))
			    {
			      eventCount["CR-top"]["met_EtSign"] += weights; 
			      if ( mll_cut("larger", 100, 100000000)) 
				{
				  eventCount["CR-top"]["mll"] += weights; 
				  
				  histogram["lepPt_CR-top"]->Fill(lepPt[Lidx1], weights);
				  histogram["mll_CR-top"]->Fill(*mll, weights);
				  histogram["met_Et_CR-top"]->Fill(*met_Et, weights );
				  histogram["mT2_CR-top"]->Fill(mT2, weights); 
				}}}}}}}}


  // CR-WW
  if ( find(regions.begin(), regions.end(), "CR-WW") != regions.end())
    {
      eventCount["CR-WW"]["Preselection"] += weights;
      if (Flavor("DF", Lidx1, Lidx2)) 
	{eventCount["CR-WW"]["Flavor"] += weights;
	  if (WantedBJets(0, nJetB))
	    {eventCount["CR-WW"]["nBjet"] += weights;
	      if (WantedLightJets(0, nJetB))
		{eventCount["CR-WW"]["nJet"] += weights;
		  if (mT2_cut("between", 60, 65))
		    {
		      eventCount["CR-WW"]["mT2"] += weights;
		      if (met_Et_cut("between", 60, 100))
			{
			  eventCount["CR-WW"]["met_Et"] += weights;
			  if (met_Sign_cut("between",5, 10))
			    {
			      eventCount["CR-WW"]["met_EtSign"] += weights; 
			      if ( mll_cut("larger", 100, 100000000))
				{
				  eventCount["CR-WW"]["mll"] += weights; 
				  
				  histogram["lepPt_CR-WW"]->Fill(lepPt[Lidx1], weights);
				  histogram["mll_CR-WW"]->Fill(*mll, weights);
				  histogram["met_Et_CR-WW"]->Fill(*met_Et, weights );
				  histogram["mT2_CR-WW"]->Fill(mT2, weights); 
				}}}}}}}}


  // CR-VZ
  if ( find(regions.begin(), regions.end(), "CR-VZ") != regions.end())
    {
      eventCount["CR-VZ"]["Preselection"] += weights;
      if (Flavor("SF", Lidx1, Lidx2)) 
	{eventCount["CR-VZ"]["Flavor"] += weights;
	  if (WantedBJets(0, nJetB))
	    {eventCount["CR-VZ"]["nBjet"] += weights;
	      if (WantedLightJets(0, nJetB))
		{eventCount["CR-VZ"]["nJet"] += weights;
		  if (mT2_cut("larger",120, 1000000000))
		    {
		      eventCount["CR-VZ"]["mT2"] += weights;
		      if (met_Et_cut("larger", 110, 100000000))
			{
			  eventCount["CR-VZ"]["met_Et"] += weights;
			  if (met_Sign_cut("larger", 10, 100000))
			    {
			      eventCount["CR-VZ"]["met_EtSign"] += weights; 
			      if ( mll_cut("between", 61.2, 121.2))
				{
				  eventCount["CR-VZ"]["mll"] += weights; 
				  
				  histogram["lepPt_CR-VZ"]->Fill(lepPt[Lidx1], weights);
				  histogram["mll_CR-VZ"]->Fill(*mll, weights);
				  histogram["met_Et_CR-VZ"]->Fill(*met_Et, weights );
				  histogram["mT2_CR-VZ"]->Fill(mT2, weights); 
				}}}}}}}}

  
  // VR-WW-0J
  if ( find(regions.begin(), regions.end(), "VR-WW-0J") != regions.end())
    {
      eventCount["VR-WW-0J"]["Preselection"] += weights;
      if (Flavor("DF", Lidx1, Lidx2))
	{
	eventCount["VR-WW-0J"]["Flavor"] += weights;
	  if (WantedLightJets(0, nJetLight))
	    {
	      eventCount["VR-WW-0J"]["nJet"] += weights;
	      if (mll_cut("larger", 100, 1000000000))
		{
		  eventCount["VR-WW-0J"]["mll"] += weights;
		  if (mT2_cut("between", 65, 100))
		    {
		      eventCount["VR-WW-0J"]["mT2"] += weights;
		      if (met_Et_cut("larger", 60, 1000000))
			{
			  eventCount["VR-WW-0J"]["met_Et"] += weights;
			  if (met_Sign_cut("larger", 5, 100000000))
			    {
			      eventCount["VR-WW-0J"]["met_EtSign"] += weights; 
			      //cuts = true;
			      histogram["lepPt_VR-WW-0J"]->Fill(lepPt[Lidx1], weights);
			      histogram["mll_VR-WW-0J"]->Fill(*mll, weights);
			      histogram["met_Et_VR-WW-0J"]->Fill(*met_Et, weights );
			      histogram["mT2_VR-WW-0J"]->Fill(mT2, weights); 
			    }}}}}}}



  // VR-WW-1J
  if  ( find(regions.begin(), regions.end(), "VR-WW-1J") != regions.end())
    {
      eventCount["VR-WW-1J"]["Preselection"] += weights;
      if (Flavor("DF", Lidx1, Lidx2))
	{
	 eventCount["VR-WW-1J"]["Flavor"] += weights;
	  if (WantedLightJets(1, nJetLight))
	    {
	      eventCount["VR-WW-1J"]["nJet"] += weights;
	      if (mll_cut("larger", 100, 10000000))
		{
		  eventCount["VR-WW-1J"]["mll"] += weights;
		  if (mT2_cut("between", 65, 100))
		    {
		      eventCount["VR-WW-1J"]["mT2"] += weights;
		      if (met_Et_cut("larger", 60, 10000000))
			{
			  eventCount["VR-WW-1J"]["met_Et"] += weights;
			  if (met_Sign_cut("larger", 5, 10000000))
			    {
			      eventCount["VR-WW-1J"]["met_EtSign"] += weights; 
			      //cuts = true;
			      histogram["lepPt_VR-WW-1J"]->Fill(lepPt[Lidx1], weights);
			      histogram["mll_VR-WW-1J"]->Fill(*mll, weights);
			      histogram["met_Et_VR-WW-1J"]->Fill(*met_Et, weights );
			      histogram["mT2_VR-WW-1J"]->Fill(mT2, weights); 
			    }}}}}}}

  


  // SR-SF-0J
  if (find(regions.begin(), regions.end(), "SR-SF-0J") != regions.end())
    {
      eventCount["SR-SF-0J"]["Preselection"] += weights;
      if (Flavor("SF", Lidx1, Lidx2))
	{
	  eventCount["SR-SF-0J"]["Flavor"] += weights;
	  if (Sign("OS", Lidx1, Lidx2))
	    {
	      eventCount["SR-SF-0J"]["Sign"] += weights;
	      if (WantedLightJets(0, nJetLight))
		{
		  eventCount["SR-SF-0J"]["nJet"] += weights;
		  if (mll_cut("larger", 121.2, 1000000000))
		    {
		      eventCount["SR-SF-0J"]["mll"] += weights; 
		      if (met_Et_cut("larger", 110, 10000000))
			{
			  eventCount["SR-SF-0J"]["met_Et"] += weights;
			  if (met_Sign_cut("larger", 10, 100000000))
			    {
			      eventCount["SR-SF-0J"]["met_EtSign"] += weights;   
			      //cuts = true;
			      histogram["lepPt_SR-SF-0J"]->Fill(lepPt[Lidx1], weights);
			      histogram["mll_SR-SF-0J"]->Fill(*mll, weights);
			      histogram["met_Et_SR-SF-0J"]->Fill(*met_Et, weights );
			      histogram["mT2_SR-SF-0J"]->Fill(mT2, weights); 
			    }}}}}}}
 
  

  // SR-SF-1J
  if (find(regions.begin(), regions.end(), "SR-SF-1J") != regions.end())
    {
      eventCount["SR-SF-1J"]["Preselection"] += weights;
      if (Flavor("SF", Lidx1, Lidx2))
	{
	  eventCount["SR-SF-1J"]["Flavor"] += weights;
	  if (Sign("OS", Lidx1, Lidx2))
	    {
	      eventCount["SR-SF-1J"]["Sign"] += weights;
	      if (WantedLightJets(1, nJetLight))
		{
		  eventCount["SR-SF-1J"]["nJet"] += weights;
		  if (mll_cut("larger", 121.2, 1000000000))
		    {
		      eventCount["SR-SF-1J"]["mll"] += weights;
		      if (met_Et_cut("larger", 110, 1000000000))
			{
			  eventCount["SR-SF-1J"]["met_Et"] += weights;
			  if (met_Sign_cut("larger", 10, 1000000000))
			    {
			      eventCount["SR-SF-1J"]["met_EtSign"] += weights;
			      //cuts = true;
			      histogram["lepPt_SR-SF-1J"]->Fill(lepPt[Lidx1], weights);
			      histogram["mll_SR-SF-1J"]->Fill(*mll, weights);
			      histogram["met_Et_SR-SF-1J"]->Fill(*met_Et, weights );
			      histogram["mT2_SR-SF-1J"]->Fill(mT2, weights); 
			    }}}}}}}		    
  


  // SR-DF-0J
  if (find(regions.begin(), regions.end(), "SR-DF-0J") != regions.end())
    {
      eventCount["SR-DF-0J"]["Preselection"] += weights;
      if (Flavor("DF", Lidx1, Lidx2))
	{
	  eventCount["SR-DF-0J"]["Flavor"] += weights;
	  if (Sign("OS", Lidx1, Lidx2))
	    {
	      eventCount["SR-DF-0J"]["Sign"] += weights;
	      if (WantedLightJets(0, nJetLight))
		{
		  eventCount["SR-DF-0J"]["nJet"] += weights;
		  if (mll_cut("larger", 100, 10000000000))
		    {
		      eventCount["SR-DF-0J"]["mll"] += weights;
		      if (met_Et_cut("larger", 110, 1000000000))
			{
			  eventCount["SR-DF-0J"]["met_Et"] += weights;
			  if (met_Sign_cut("larger", 10, 100000000))
			    {
			      eventCount["SR-DF-0J"]["met_EtSign"] += weights;
			      //cuts = true;
			      histogram["lepPt_SR-DF-0J"]->Fill(lepPt[Lidx1], weights);
			      histogram["mll_SR-DF-0J"]->Fill(*mll, weights);
			      histogram["met_Et_SR-DF-0J"]->Fill(*met_Et, weights );
			      histogram["mT2_SR-DF-0J"]->Fill(mT2, weights); 
			    }}}}}}}



  // SR-DF-1J
  if  (find(regions.begin(), regions.end(), "SR-DF-0J") != regions.end())
    {
      eventCount["SR-DF-1J"]["Preselection"] += weights;
      if (Flavor("DF", Lidx1, Lidx2))
	{
	  eventCount["SR-DF-1J"]["Flavor"] += weights;
	  if (Sign("OS", Lidx1, Lidx2))
	    {
	      eventCount["SR-DF-1J"]["Sign"] += weights;
	      if (WantedLightJets(1, nJetLight))
		{ 
		  eventCount["SR-DF-1J"]["nJet"] += weights;
		  if (mll_cut("larger", 100, 1000000000))
		    {
		      eventCount["SR-DF-1J"]["mll"] += weights;
		      if (met_Et_cut("larger", 110, 100000000))
			{
			  eventCount["SR-DF-1J"]["met_Et"] += weights;
			  if (met_Sign_cut("larger", 10, 100000000))
			    {
			      eventCount["SR-DF-1J"]["met_EtSign"] += weights;
			      //cuts = true;
			      histogram["lepPt_SR-DF-1J"]->Fill(lepPt[Lidx1], weights);
			      histogram["mll_SR-DF-1J"]->Fill(*mll, weights);
			      histogram["met_Et_SR-DF-1J"]->Fill(*met_Et, weights );
			      histogram["mT2_SR-DF-1J"]->Fill(mT2, weights); 
			    }}}}}}}



  // Cuts ee or mumu 

  //SR-SF-0J-ee
  if(find(regions.begin(), regions.end(), "SR-SF-0J-ee") != regions.end())
    {
      eventCount["SR-SF-0J-ee"]["Preselection"] += weights;
      if (Flavor("SF", Lidx1, Lidx2))
	{
	  if (lepFlavor[Lidx1] == 1 and lepFlavor[Lidx2] == 1)
	    {
	      eventCount["SR-SF-0J-ee"]["Flavor"] += weights;
	      if (Sign("OS", Lidx1, Lidx2))
		{
		  eventCount["SR-SF-0J-ee"]["Sign"] += weights;
		  if (WantedLightJets(0, nJetLight))
		    {
		      eventCount["SR-SF-0J-ee"]["nJet"] += weights;
		      if (mll_cut("larger", 121.2, 100000000))
			{
			  eventCount["SR-SF-0J-ee"]["mll"] += weights; 
			  if (met_Et_cut("larger", 110, 100000000))
			    {
			      eventCount["SR-SF-0J-ee"]["met_Et"] += weights;
			      if (met_Sign_cut("larger", 10, 1000000000))
				{
				  eventCount["SR-SF-0J-ee"]["met_EtSign"] += weights;
				  //cuts = true;
				  histogram["lepPt_SR-SF-0J-ee"]->Fill(lepPt[Lidx1], weights);
				  histogram["mll_SR-SF-0J-ee"]->Fill(*mll, weights);
				  histogram["met_Et_SR-SF-0J-ee"]->Fill(*met_Et, weights );
				  histogram["mT2_SR-SF-0J-ee"]->Fill(mT2, weights); 
				}}}}}}}}



  //SR-SF-1J-ee
  if (find(regions.begin(), regions.end(), "SR-SF-1J-ee") != regions.end())
    {
      eventCount["SR-SF-1J-ee"]["Preselection"] += weights;
      if (Flavor("SF", Lidx1, Lidx2))
	{
	  if (lepFlavor[Lidx1] == 1 and lepFlavor[Lidx2] == 1)
	    {
	      eventCount["SR-SF-1J-ee"]["Flavor"] += weights;
	      if (Sign("OS", Lidx1, Lidx2))
		{
		  eventCount["SR-SF-1J-ee"]["Sign"] += weights;
		  if (WantedLightJets(1, nJetLight))
		    {
		      eventCount["SR-SF-1J-ee"]["nJet"] += weights;
		      if (mll_cut("larger", 121.2, 10000000000))
			{
			  eventCount["SR-SF-1J-ee"]["mll"] += weights; 
			  if (met_Et_cut("larger", 110, 1000000000))
			    {
			      eventCount["SR-SF-1J-ee"]["met_Et"] += weights;
			      if (met_Sign_cut("larger", 10, 100000000))
				{
				  eventCount["SR-SF-1J-ee"]["met_EtSign"] += weights;
				  //cuts = true;
				  histogram["lepPt_SR-SF-1J-ee"]->Fill(lepPt[Lidx1], weights);
				  histogram["mll_SR-SF-1J-ee"]->Fill(*mll, weights);
				  histogram["met_Et_SR-SF-1J-ee"]->Fill(*met_Et, weights );
				  histogram["mT2_SR-SF-1J-ee"]->Fill(mT2, weights);
				}}}}}}}}



  //SR-SF-0J-mumu
  if (find(regions.begin(), regions.end(), "SR-SF-0J-mumu") != regions.end())
    {
      eventCount["SR-SF-0J-mumu"]["Preselection"] += weights;
      if (Flavor("SF", Lidx1, Lidx2))
	{
	  if (lepFlavor[Lidx1] != 1 and lepFlavor[Lidx2] != 1)
	    {
	      eventCount["SR-SF-0J-mumu"]["Flavor"] += weights;
	      if (Sign("OS", Lidx1, Lidx2))
		{
		  eventCount["SR-SF-0J-mumu"]["Sign"] += weights;
		  if (WantedLightJets(0, nJetLight))
		    {
		      eventCount["SR-SF-0J-mumu"]["nJet"] += weights;
		      if (mll_cut("larger", 121.2, 100000000))
			{
			  eventCount["SR-SF-0J-mumu"]["mll"] += weights; 
			  if (met_Et_cut("larger", 110, 100000000))
			    {
			      eventCount["SR-SF-0J-mumu"]["met_Et"] += weights;
			      if (met_Sign_cut("larger", 10, 10000000000))
				{
				  eventCount["SR-SF-0J-mumu"]["met_EtSign"] += weights;
				  //cuts = true;
				  histogram["lepPt_SR-SF-0J-mumu"]->Fill(lepPt[Lidx1], weights);
				  histogram["mll_SR-SF-0J-mumu"]->Fill(*mll, weights);
				  histogram["met_Et_SR-SF-0J-mumu"]->Fill(*met_Et, weights );
				  histogram["mT2_SR-SF-0J-mumu"]->Fill(mT2, weights); 
				}}}}}}}}



  //SR-SF-1J-mumu
  if (find(regions.begin(), regions.end(), "SR-SF-1J-mumu") != regions.end())
    {
      eventCount["SR-SF-1J-mumu"]["Preselection"] += weights;
      if (Flavor("SF", Lidx1, Lidx2))
	{
	  if (lepFlavor[Lidx1] != 1 and lepFlavor[Lidx2] != 1)
	    {
	      eventCount["SR-SF-1J-mumu"]["Flavor"] += weights;
	      if (Sign("OS", Lidx1, Lidx2))
		{
		  eventCount["SR-SF-1J-mumu"]["Sign"] += weights;
		  if (WantedLightJets(1, nJetLight))
		    {
		      eventCount["SR-SF-1J-mumu"]["nJet"] += weights;
		      if (mll_cut("larger", 121.2, 100000000))
			{
			  eventCount["SR-SF-1J-mumu"]["mll"] += weights; 
			  if (met_Et_cut("larger", 110, 1000000000))
			    {
			      eventCount["SR-SF-1J-mumu"]["met_Et"] += weights;
			      if (met_Sign_cut("larger", 10, 100000000))
				{
				  eventCount["SR-SF-1J-mumu"]["met_EtSign"] += weights;
				  // cuts = true;
				  histogram["lepPt_SR-SF-1J-mumu"]->Fill(lepPt[Lidx1], weights);
				  histogram["mll_SR-SF-1J-mumu"]->Fill(*mll, weights);
				  histogram["met_Et_SR-SF-1J-mumu"]->Fill(*met_Et, weights );
				  histogram["mT2_SR-SF-1J-mumu"]->Fill(mT2, weights);	  
				}}}}}}}}

  

  //==================================================
  //
  // Part for filling histograms - NOT NEEDED WHEN WE FILL IN EACH REGION
  //
  //================================================== 
  /*
  if (cuts == true)
    { 
      histogram["lepPt"]->Fill(lepPt[Lidx1], weights);
      histogram["mll"]->Fill(*mll, weights);
      histogram["met_Et"]->Fill(*met_Et, weights );
      histogram["mT2"]->Fill(mT2, weights); 
    }
  */

   return kTRUE;

}
// Process - end
//====================================================================================================





void MySelector::SlaveTerminate()
{
   // The SlaveTerminate() function is called after all entries or objects
   // have been processed. When running with PROOF SlaveTerminate() is called
   // on each slave server.
}
// SlaveTerminate - end
//====================================================================================================





void MySelector::Terminate()
{
   // The Terminate() function is the last function to be called during
   // a query. It always runs on the client, it can be used to present
   // the results graphically or save the results to file.


  //==================================================
  //
  // Saving histograms
  //
  //================================================== 

  // Save files background
  if (inputType == "bkg")
   {
    
     TString ROOTFile_save_path = saving_path + "/" + background_elm + "_" + timeperiod + ".root";
     TFile *myfile = new TFile(ROOTFile_save_path, "RECREATE");
     for (int i = 0, k = myString.size(); i < k; i++)
       {
	 histogram[myString[i]]->Write();
       }
     histogram2D["nlepbase_vs_nlepsign"]->Write();
     myfile->Close(); 
    }


  // Save files fakes
  if (inputType == "fakes")
   {

     TString ROOTFile_save_path = saving_path + "/"  + "fakes_" + timeperiod + ".root";
     TFile *myfile = new TFile(ROOTFile_save_path, "RECREATE");
     for (int i = 0, k = myString.size(); i < k; i++)
       {
	 histogram[myString[i]]->Write();
       }
     histogram2D["nlepbase_vs_nlepsign"]->Write();
     myfile->Close(); 
    }

  // Save files data
 
  if (inputType == "data")
   {
     
     TString ROOTFile_save_path = saving_path + "/" + data_name + "_" + timeperiod + ".root";
     TFile *myfile = new TFile(ROOTFile_save_path, "RECREATE");
     for (int i = 0, k = myString.size(); i < k; i++)
       {
	 histogram[myString[i]]->Write();
       }

     histogram2D["nlepbase_vs_nlepsign"]->Write();
     myfile->Close();
   }

  // Save files signal
  if (inputType == "signal")
    {
      TString ROOTFile_save_path = saving_path + "/" + signal_samp + "_" + timeperiod + ".root";
      TFile *myfile = new TFile(ROOTFile_save_path, "RECREATE");
      for (int i = 0, k = myString.size(); i < k; i++)
       {
	 histogram[myString[i]]->Write();
       }
      histogram2D["nlepbase_vs_nlepsign"]->Write();
      myfile->Close();
    }

  //==================================================
  //
  // Logfile
  //
  //================================================== 

  fstream logfile; 


  logfile.open(saving_path + "/Logfile/logfile.txt", ios::app);
  logfile << " " << endl;


  map<TString,map<TString,float>>::iterator itr;
  map<TString,float>::iterator ptr;

  if (inputType == "bkg")
    { 
      for ( itr = eventCount.begin(); itr != eventCount.end(); itr ++)
	{
	  for (ptr = itr->second.begin(); ptr != itr->second.end(); ptr++)
	    {
	      logfile << background_elm << ":" << timeperiod << ":" << itr->first << ":" <<  ptr->first << ":" << ptr->second << endl;
	    }
	}
    }

  if (inputType == "fakes")
    { 
      for ( itr = eventCount.begin(); itr != eventCount.end(); itr ++)
	{
	  for (ptr = itr->second.begin(); ptr != itr->second.end(); ptr++)
	    {
	      logfile << inputType << ":" << timeperiod << ":" << itr->first << ":" <<  ptr->first << ":" << ptr->second << endl;
	    }
	}
    }

 
  if (inputType == "data")
    { 
      for ( itr = eventCount.begin(); itr != eventCount.end(); itr ++)
	{
	  for (ptr = itr->second.begin(); ptr != itr->second.end(); ptr++)
	    {
	      logfile << data_name << ":" << timeperiod << ":" << itr->first << ":" <<  ptr->first << ":" << ptr->second << endl;
	    }
	}
    }


  if (inputType == "signal")
    { 
      for ( itr = eventCount.begin(); itr != eventCount.end(); itr ++)
	{
	  for (ptr = itr->second.begin(); ptr != itr->second.end(); ptr++)
	    {
	      logfile << signal_samp << ":" << timeperiod << ":" << itr->first << ":" <<  ptr->first << ":" << ptr->second << endl;
	    }
	}
    }


	

  logfile.close();


}
// Terminate - end
//====================================================================================================





//==================================================
//
// Functions
//
//================================================== 


bool MySelector::isSignalLep (int index, TString iso_point){

  bool isEl = false;                                                                                                                   
  bool isMu = false;                                                                                                                       
  if(lepFlavor[index] == 1)isEl = true;                                                                                                   
  else isMu = true;        
            
  if((isMu && lepD0Sig[index] >= 3) || (isEl && lepD0Sig[index] >= 5))return false;

  if (iso_point == "1" or iso_point == "3")
    {
      if((isMu && !lepMedium->at(index)) || (isEl && !lepMedium->at(index)))return false;  //run with no restriction on baseline leptons
    }

  else
    {
      if((isMu && !lepTight->at(index)) || (isEl && !lepTight->at(index)))return false;   //run with restrictions on baseline leptons
    }

  
  if (iso_point == "0" or iso_point == "1")
    {
      if(isMu && !lepIsoFCLoose->at(index))return false;                                                                                                                                                                                             
      if(isEl)
	{                                                                                                                                                                                                                                                                     
	  if(lepPt[index] < 200 && !lepIsoFCLoose->at(index))return false;                                                                                                                                                       
	  else if(lepPt[index] >= 200 && !lepIsoFCHighPtCaloOnly->at(index))return false;  
	}
    }
  else
    {
      if (!lepIsoFCTight->at(index)) return false;  
    }

  return true;
}


bool MySelector::WantedLightJets(int nWanted,int njetslight){

  if ((nWanted == 0 && njetslight == 0) || (nWanted == 1 && njetslight ==1))
      {return true;}
  else
    {return false;}

  return false;
			
}


bool MySelector::WantedBJets(int nWanted,int njetsB){

  if ((nWanted == 0 && njetsB == 0) || (nWanted == 1 && njetsB ==1))
      {return true;}
  else
    {return false;}

  return false;
			
}


bool MySelector::Sign(string sign, int lepIndex1, int lepIndex2){
  if ((sign == "OS" && lepCharge[lepIndex1]*lepCharge[lepIndex2] < 0 )
      ||(sign == "SS" && lepCharge[lepIndex1]*lepCharge[lepIndex2] > 0 ))
    {return true;}
  else
    {return false;}
  return false;
}


bool MySelector::Flavor(string flavor ,int lepIndex1, int lepIndex2){

  if ((flavor == "SF" && lepFlavor[lepIndex1] == lepFlavor[lepIndex2]) 
      ||(flavor == "DF" && lepFlavor[lepIndex1] != lepFlavor[lepIndex2]))
    {return true;}
  else
    {return false;}
  return false;
}


bool MySelector::mll_cut(string largerORsmaller,float mll_cut_value_low = 0, float mll_cut_value_high=1000000 ){
  if (largerORsmaller == "larger" or largerORsmaller == "l")
    {
      if ( *mll > mll_cut_value_low) 
	{return true;}
      else
	{return false;}
    }

  if(largerORsmaller == "smaller" or largerORsmaller == "s")
    {
      if (*mll <  mll_cut_value_high)
	{return true;}
      else
	{return false;}
    }

  if(largerORsmaller == "between" or largerORsmaller == "b")
    {
      if (mll_cut_value_low < *mll <  mll_cut_value_high)
	{return true;}
      else
	{return false;}
    }

  return false;
}


bool MySelector::rmZpeak(int dist_from_Z){
  if ( fabs(*mll - 91) > dist_from_Z)
    {return true;}
  else
    {return false;}

  return false;

}


bool MySelector::lepPt_cut(string largerORsmaller,int lepIndex1, int lepIndex2, float lepPt_cut_value){
  if (largerORsmaller == "larger" or largerORsmaller == "l")
    {
      if (lepPt[lepIndex1] > lepPt_cut_value && lepPt[lepIndex2] >  lepPt_cut_value)
	{return true;}
      else
	{return false;}
    }

  if (largerORsmaller == "smaller" or largerORsmaller == "s")
    {
      if (lepPt[lepIndex1] < lepPt_cut_value && lepPt[lepIndex2] <  lepPt_cut_value)
	{return true;}
      else
	{return false;}
    }

  return false;
}


bool MySelector::met_Et_cut(string largerORsmaller, float met_Et_cut_value_low=0, float met_Et_cut_value_high=1000000 ){

  if (largerORsmaller == "larger" or largerORsmaller == "l")
    {
      if  (*met_Et > met_Et_cut_value_low)
	{return true;}
      else
	{return false;}
    }

  if(largerORsmaller == "smaller" or largerORsmaller == "s")
    {
      if  (*met_Et < met_Et_cut_value_high)
	{return true;}
      else
	{return false;}
    }

  if(largerORsmaller == "between" or largerORsmaller == "b")
    {
      if  (met_Et_cut_value_low < *met_Et < met_Et_cut_value_high)
	{return true;}
      else
	{return false;}
    }


  return false;

}


bool MySelector::met_Sign_cut(string largerORsmaller, float met_Sign_cut_value_low=0, float met_Sign_cut_value_high=1000000){
  if (largerORsmaller == "larger" or largerORsmaller == "l")
    {
      if  (*met_Sign > met_Sign_cut_value_low)
	{return true;}
      else
	{return false;}
    }

  if(largerORsmaller == "smaller" or largerORsmaller == "s")
    {
      if  (*met_Sign < met_Sign_cut_value_high)
	{return true;}
      else
	{return false;}
    }


  if(largerORsmaller == "between" or largerORsmaller == "b")
    {
      if  (met_Sign_cut_value_low < *met_Sign < met_Sign_cut_value_high)
	{return true;}
      else
	{return false;}
    }


  return false;
}

bool MySelector::mT2_cut(string type_interval, float limit_low = 0, float limit_high = 1000000){
  if (type_interval == "binned")
    {
      if ( limit_low <= mT2 and mT2 < limit_high)
	{return true;}
      else
	{return false;}
    }
  
  if (type_interval == "inclusive")
    {
      if (limit_low <= mT2)
	{return true;}
      else
	{return false;}
    }
  
  if (type_interval == "between")
    {
      if ( limit_low <= mT2 and mT2 <= limit_high)
	{return true;}
      else
	{return false;}
    }
  return false;
}
